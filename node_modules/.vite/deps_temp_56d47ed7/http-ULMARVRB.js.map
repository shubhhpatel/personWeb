{
  "version": 3,
  "sources": ["../../refractor/lang/http.js"],
  "sourcesContent": ["// @ts-nocheck\nhttp.displayName = 'http'\nhttp.aliases = []\n\n/** @type {import('../core.js').Syntax} */\nexport default function http(Prism) {\n  ;(function (Prism) {\n    /**\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function headerValueOf(name) {\n      return RegExp('(^(?:' + name + '):[ \\t]*(?![ \\t]))[^]+', 'i')\n    }\n    Prism.languages.http = {\n      'request-line': {\n        pattern:\n          /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\n        inside: {\n          // HTTP Method\n          method: {\n            pattern: /^[A-Z]+\\b/,\n            alias: 'property'\n          },\n          // Request Target e.g. http://example.com, /path/to/file\n          'request-target': {\n            pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n            lookbehind: true,\n            alias: 'url',\n            inside: Prism.languages.uri\n          },\n          // HTTP Version\n          'http-version': {\n            pattern: /^(\\s)HTTP\\/[\\d.]+/,\n            lookbehind: true,\n            alias: 'property'\n          }\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\n        inside: {\n          // HTTP Version\n          'http-version': {\n            pattern: /^HTTP\\/[\\d.]+/,\n            alias: 'property'\n          },\n          // Status Code\n          'status-code': {\n            pattern: /^(\\s)\\d+(?=\\s)/,\n            lookbehind: true,\n            alias: 'number'\n          },\n          // Reason Phrase\n          'reason-phrase': {\n            pattern: /^(\\s).+/,\n            lookbehind: true,\n            alias: 'string'\n          }\n        }\n      },\n      header: {\n        pattern: /^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,\n        inside: {\n          'header-value': [\n            {\n              pattern: headerValueOf(/Content-Security-Policy/.source),\n              lookbehind: true,\n              alias: ['csp', 'languages-csp'],\n              inside: Prism.languages.csp\n            },\n            {\n              pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\n              lookbehind: true,\n              alias: ['hpkp', 'languages-hpkp'],\n              inside: Prism.languages.hpkp\n            },\n            {\n              pattern: headerValueOf(/Strict-Transport-Security/.source),\n              lookbehind: true,\n              alias: ['hsts', 'languages-hsts'],\n              inside: Prism.languages.hsts\n            },\n            {\n              pattern: headerValueOf(/[^:]+/.source),\n              lookbehind: true\n            }\n          ],\n          'header-name': {\n            pattern: /^[^:]+/,\n            alias: 'keyword'\n          },\n          punctuation: /^:/\n        }\n      }\n    }\n\n    // Create a mapping of Content-Type headers to language definitions\n    var langs = Prism.languages\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css,\n      'text/plain': langs.plain\n    }\n\n    // Declare which types can also be suffixes\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    }\n\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '')\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])'\n      return '(?:' + contentType + '|' + suffixPattern + ')'\n    }\n\n    // Insert each content type parser that has its associated language\n    // currently loaded.\n    var options\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {}\n        var pattern = suffixTypes[contentType]\n          ? getSuffixPattern(contentType)\n          : contentType\n        options[contentType.replace(/\\//g, '-')] = {\n          pattern: RegExp(\n            '(' +\n              /content-type:\\s*/.source +\n              pattern +\n              /(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source +\n              ')' +\n              // This is a little interesting:\n              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\n              // However, when writing code by hand (e.g. to display on a website) people can forget about this,\n              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\n              // the body does not start with a [\\w-] character (as headers do).\n              /[^ \\t\\w-][\\s\\S]*/.source,\n            'i'\n          ),\n          lookbehind: true,\n          inside: httpLanguages[contentType]\n        }\n      }\n    }\n    if (options) {\n      Prism.languages.insertBefore('http', 'header', options)\n    }\n  })(Prism)\n}\n"],
  "mappings": "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",
  "names": ["Prism", "contentType"]
}
