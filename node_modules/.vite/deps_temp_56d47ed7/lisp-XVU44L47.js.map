{
  "version": 3,
  "sources": ["../../refractor/lang/lisp.js"],
  "sourcesContent": ["// @ts-nocheck\nlisp.displayName = 'lisp'\nlisp.aliases = ['elisp', 'emacs', 'emacs-lisp']\n\n/** @type {import('../core.js').Syntax} */\nexport default function lisp(Prism) {\n  ;(function (Prism) {\n    /**\n     * Functions to construct regular expressions\n     * e.g. (interactive ... or (interactive)\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function simple_form(name) {\n      return RegExp(/(\\()/.source + '(?:' + name + ')' + /(?=[\\s\\)])/.source)\n    }\n    /**\n     * booleans and numbers\n     *\n     * @param {string} pattern\n     * @returns {RegExp}\n     */\n    function primitive(pattern) {\n      return RegExp(\n        /([\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\s)])/.source\n      )\n    }\n\n    // Patterns in regular expressions\n\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = /(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source\n    // symbol starting with & used in function arguments\n    var marker = '&' + symbol\n    // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))'\n    // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var nestedPar =\n      /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/\n        .source\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:append|by|collect|concat|do|finally|for|in|return)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form(/declare/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form(/interactive/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive(/nil|t/.source),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            /(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source +\n            symbol +\n            /\\s+\\(/.source +\n            nestedPar +\n            /\\)/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(\n          par +\n            'lambda\\\\s+\\\\(\\\\s*(?:&?' +\n            symbol +\n            '(?:\\\\s+&?' +\n            symbol +\n            ')*\\\\s*)?\\\\)'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(?:['`,]?\\(|[)\\[\\]])/,\n        // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      varform: {\n        pattern: RegExp(\n          /\\(/.source + symbol + /\\s+(?=\\S)/.source + nestedPar + /\\)/.source\n        ),\n        inside: language\n      },\n      argument: {\n        pattern: RegExp(/(^|[\\s(])/.source + symbol),\n        lookbehind: true,\n        alias: 'variable'\n      },\n      rest: language\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + nestedPar + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:body|rest)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n"],
  "mappings": "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",
  "names": ["Prism"]
}
